import { ICache } from "./Cache";
import { IUser } from "./User";
import { ILogger } from "../logging/Logger";
import { IDataSynchronizer } from "../streaming/DataSynchronizer";
import { IClientContext } from "./ClientContext";
import { IDataSourceUpdates } from "../subsystems/DataSourceUpdates";
import { VoidFunction } from "../utils/VoidFunction";

export interface IOptions {
    sdkKey?: string;

    /**
     * The base URI for the FeatBit Evaluation server.
     */
    baseUri?: string;

    cache?: ICache;

    context?: IUser;

    /**
     * Whether streaming mode should be used to receive flag updates.
     *
     * This is true by default. If you set it to false, the client will use polling.
     * Streaming should only be disabled on the advice of LaunchDarkly support.
     */
    stream?: boolean;

    /**
     * The time between polling requests, in milliseconds, if less than 30 000 ms, 30 000 ms would be used. Ignored in streaming mode.
     */
    pollInterval?: number;

    /**
     * The interval in between flushes of events queue, in milliseconds.
     *
     * The default value is 2 000 milliseconds.
     */
    flushInterval?: number;

    /**
     * The max number of events in the events queue.
     * defaults to 10 000
     */
    maxEventsInQueue?: number;

    /**
     * Configures a logger for warnings and errors generated by the SDK.
     *
     * The logger can be any object that conforms to the {@link ILogger} interface.
     * For a simple implementation that lets you filter by log level, see
     * {@link BasicLogger}. You can also use an instance of `winston.Logger` from
     * the Winston logging package.
     *
     * If you do not set this property, the SDK uses {@link BasicLogger} with a
     * minimum level of `info`.
     */
    logger?: ILogger;

    /**
     *  Timeout in milliseconds for the WebSocket handshake request. This is reset after every redirection.
     */
    webSocketHandshakeTimeout?: number;

    /**
     * A component that obtains feature flag and segment data and puts it in the store.
     *
     * By default, this is the client's default streaming or polling component.
     */
    dataSynchronizer?:
      | object
      | ((
      clientContext: IClientContext,
      dataSourceUpdates: IDataSourceUpdates,
      initSuccessHandler: VoidFunction,
      errorHandler?: (e: Error) => void,
    ) => IDataSynchronizer);
}